/******************************************************************************
 *
 *                          MPP: An MPI CPP Interface
 *
 *                  Copyright (C) 2011-2012  Simone Pellegrini
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 ******************************************************************************/

#pragma once

/**
 * Contains the defition of the status wrapper which exists fof the sake of
 * encapsulating the MPI_Status object.
 */

#include "mpp/decls.h"

#include <memory>

namespace mpp {

struct status{

	// converted to shared_ptr to allow safer checking in the face of errors
	typedef std::shared_ptr<MPI_Status> mpi_status_ptr;

	status(status&& other) :
		m_comm(std::move(other.m_comm)),
		m_status(std::move(other.m_status)),
		m_datatype(other.m_datatype) { }

	inline endpoint source();

	// added as safety check that m_status manages an object, CACZ 14-4-18
	inline bool check() const {
		return bool(m_status);
	}

	// made safe with a call to check(), if unsafe returns MPI_UNDEFINED, CACZ 14-4-18
	inline int count() const {
		if ( !check() ) { return undefined; }
		int count;
		MPI_Get_count(m_status.get(), m_datatype, &count);
		return count;
	}

	// made safe with a call to check(), if unsafe returns MPI_UNDEFINED, CACZ 14-4-18
	inline int tag() const {
		if ( !check() ) { return undefined; }
		return m_status->MPI_TAG;
	}

	// made safe with a call to check(), if unsafe returns MPI_UNDEFINED, CACZ 14-4-18
	inline int error() const {
		if ( !check() ) { return undefined; }
		return m_status->MPI_ERROR;
	}

	/**
	 * Friend classes declarations
	 */
	friend class endpoint;

	template <class T>
	friend class request;

private:

	/**
	 * Avoid the generation of status objects, these objects are generated by
	 * the MPP library and it would make no sense if the user could
	 * automatically generate one of those
	 */
	status(const comm& com, mpi_status_ptr&& s, const MPI_Datatype& dt):
		m_comm(com),
		m_status(std::move(s)),
		m_datatype(dt) { }

	status(const status& other) = delete;
	status& operator=(const status& other) = delete;

	const comm&      	m_comm;
	mpi_status_ptr		m_status;
	const MPI_Datatype  m_datatype;
};

} // end mpi namespace

#include "mpp/endpoint.h"

namespace mpp {

// made safe with a call to check(), if unsafe returns an endpoint to MPI_UNDEFINED, CACZ 14-4-18
inline endpoint status::source() {
	if ( !check() ) { return endpoint(undefined, m_comm); }
	return endpoint(m_status->MPI_SOURCE, m_comm);
}


} // end mpi namespace

